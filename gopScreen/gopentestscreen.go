package gopscreen

import (
	"bufio"
	"fmt"
	"net/url"
	"os"
	"sync"
	"time"

	"github.com/hophouse/gop/screenshot"
	"github.com/hophouse/gop/utils"
)

var (
	wg sync.WaitGroup
)

func RunScreenCmd(reader *os.File, proxy string, concurrency int, timeout int, delay int, cookie string) {
	inputChan := make(chan *url.URL, concurrency)
	workerChan := make(chan bool)
	outputChan := make(chan screenshot.Screenshot)

	begin := time.Now()

	// bars
	progressBars := utils.InitWaitGroupBar()
	utils.ScreenshotBar = progressBars.AddBar("Screenshot", false)

	// Screenshot list
	screenshotList := []screenshot.Screenshot{}

	// Launch the workers that will process the outputs
	go func(outputChan chan screenshot.Screenshot, workerChan chan bool, screenshotList *[]screenshot.Screenshot) {
		for item := range outputChan {
			// consume output
			*screenshotList = append(*screenshotList, item)
		}
		workerChan <- true
	}(outputChan, workerChan, &screenshotList)

	directory, _ := os.Getwd()

	// Launch the workers
	for i := 0; i < concurrency; i++ {
		go func(inputChan chan *url.URL, workerChan chan bool, outputChan chan screenshot.Screenshot) {
			for requestURL := range inputChan {
				utils.Log.Printf("[+] Taking screenshot for %s\n", requestURL)

				// Go make the screenshot
				screenshot.TakeScreenShot(requestURL.String(), directory+"/", cookie, proxy)

				// Add screenshot to list
				outputChan <- screenshot.Screenshot{
					Url:           requestURL.String(),
					RequestStatus: "Uknown",
				}
			}
			workerChan <- true
		}(inputChan, workerChan, outputChan)
	}

	// Fill the input channel with entries
	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		url, err := url.Parse(scanner.Text())
		if err != nil {
			utils.Log.Println(err)
			fmt.Printf("[Error] %s\n", url.String())
			continue
		}
		utils.ScreenshotBar.Add(1)
		inputChan <- url
	}
	close(inputChan)

	// Wait for workers to finish
	for i := 0; i < concurrency; i++ {
		<-workerChan
	}
	close(outputChan)

	// Wait for the output chan to finish processing outputs
	<-workerChan

	// Generate template
	f, err := os.Create("../index.html")
	if err != nil {
		utils.Log.Println(err)
	}
	f.WriteString(screenshot.GetScreenshotHTML(screenshotList))

	end := time.Now()
	fmt.Printf("\n[+] Execution time : %s\n", end.Sub(begin))

	/*
		// Scanner to read file
		// scanner := bufio.NewScanner(reader)
		for scanner.Scan() {
			url, err := url.Parse(scanner.Text())
			if err != nil {
				utils.Log.Println(err)
				fmt.Printf("[Error] %s\n", url.String())
				continue
			}

			utils.ScreenshotBar.Add(1)
			go func(sl *[]screenshot.Screenshot) {
				//defer utils.ScreenshotBar.Done()
				concurrencyChan <- struct{}{}

				// Take screenshot
				screenshot.TakeScreenShot(url.String(), "", cookie, proxy)

				// Add screenshot to list
				*sl = append(*sl, screenshot.Screenshot{
					Url:           url.String(),
					RequestStatus: "Uknown",
				})

				<-concurrencyChan
			}(&screenshotList)

			time.Sleep(time.Duration(delay) * time.Second)
		}
		if err := scanner.Err(); err != nil {
			utils.Log.Fatal(err)
		}

		progressBars.Wait()
	*/
}
