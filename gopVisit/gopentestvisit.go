package gopvisit

import (
    "bufio"
    "fmt"
    "time"
    "os"
    "net/http"
    "net/url"
    "crypto/tls"
    "sync"

    "github.com/hophouse/gop/utils"
)

var (
    wg sync.WaitGroup
)

func RunVisitCmd(reader *os.File, proxy string) {
    begin := time.Now()

    // Create HTTP Client
    client := newClient(proxy)

    // Scanner to read file
	scanner := bufio.NewScanner(reader)
    for scanner.Scan() {
        url, err := url.Parse(scanner.Text())
        if err != nil {
            utils.Log.Println(err)
            fmt.Printf("[Error] %s\n", url.String())
            continue
        }

        wg.Add(1)
        go func () {
            resp, err := visitUrl(client, url.String())
            if err != nil {
                fmt.Printf("[ERROR] %s : %s\n", url, err)
                utils.Log.Printf("[!] Error with URL : %s, %s", url, err)
                return
            }
            fmt.Printf("[%s] %s\n", resp.Status, url)
        }()
    }
    if err := scanner.Err(); err != nil {
        utils.Log.Fatal(err)
    }

    wg.Wait()
    end := time.Now()
	fmt.Printf("\n[+] Execution time : %s\n", end.Sub(begin))
}

func newClient(proxy string) (*http.Client) {
    tr := http.DefaultTransport.(*http.Transport).Clone()
    tr.DisableKeepAlives = true
    tr.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
    // Disable HTTP/2.
    tr.TLSNextProto = make(map[string]func(authority string, c *tls.Conn) http.RoundTripper)

    if proxy != "" {
        proxyUrl, err := url.Parse(proxy)
        if err != nil {
                utils.Log.Fatal(err)
            }
        tr.Proxy = http.ProxyURL(proxyUrl)
    }

    client := &http.Client{Transport: tr}
    client.Timeout= 10 * time.Second
    client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
        return http.ErrUseLastResponse
    }

    return client
}

func visitUrl(client *http.Client, url string) (*http.Response, error) {
    defer wg.Done()

    resp, err := client.Get(url)
    if err != nil {
        return resp, err
    }
    defer resp.Body.Close()

    return resp, nil
}
